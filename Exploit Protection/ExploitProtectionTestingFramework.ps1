#Requires -RunAsAdministrator

<#
.SYNOPSIS
    A framework to automatically test and apply Exploit Protection mitigations for a target application.

.DESCRIPTION
    This script iterates through all available Exploit Protection settings. For each setting, it:
    1. Enables the mitigation.
    2. Launches the target application in the correct user context with a test resource (URL or file).
    3. Waits for a specified delay.
    4. Checks for security mitigation events in the Windows Event Log.
    5. If an event is found, it disables the unstable mitigation. Otherwise, it leaves it enabled.
    6. Produces a final report of stable and unstable mitigations.
#>



#------------------------------------------------------------------------------------
# --- CONFIGURATION BLOCK - PASTE THE DESIRED APP CONFIGURATION HERE ---
#------------------------------------------------------------------------------------

# This section will be replaced by one of the application-specific blocks from the guide.
$friendlyAppName = "Microsoft Word"
$appName         = "WINWORD.EXE"
$appType         = "DocumentApp" # 'Browser' or 'DocumentApp'
$testResource    = "C:\Automated_App_Testing\test.docx"
$delayInSeconds  = 10 # Longer delay for larger Office apps

#------------------------------------------------------------------------------------
# --- SCRIPT ENGINE - DO NOT MODIFY BELOW THIS LINE ---
#------------------------------------------------------------------------------------

#region Helper Functions

function Get-AllMitigationNames {
    param ([string]$TargetAppName)
    $mitigationObject = Get-ProcessMitigation -Name $TargetAppName -ErrorAction Stop
    $discoveredNames = [System.Collections.Generic.List[string]]::new()
    $topLevelGroups = $mitigationObject.psobject.Properties | Where-Object { $_.Name -notin 'ProcessName', 'Id', 'Source' }
    foreach ($group in $topLevelGroups) {
        $discoveredNames.Add($group.Name)
        $nestedObject = $group.Value
        if ($nestedObject -and $nestedObject.psobject.Properties.Count -gt 0) {
            $subProperties = $nestedObject.psobject.Properties
            foreach ($subProp in $subProperties) { $discoveredNames.Add($subProp.Name) }
        }
    }
    return $discoveredNames | Select-Object -Unique | Where-Object { $_ -notlike "*Override*" -and $_ -ne "EAFModules" }
}

function Test-MitigationState {
    param ([string]$TargetAppName, [string]$MitigationName)
    $settings = Get-ProcessMitigation -Name $TargetAppName -ErrorAction Stop
    $policyObjects = $settings.psobject.Properties | Where-Object { $_.Name -notin 'ProcessName', 'Id', 'Source' }
    foreach ($policy in $policyObjects) {
        $policyObject = $policy.Value
        # Case 1: The top-level policy object itself represents the state
        if ($policy.Name -eq $MitigationName -and $policyObject.ToString() -eq 'ON') {
            return $true
        }
        # Case 2: The state is in a nested property
        if ($policyObject -and $policyObject.psobject.Properties.Count -gt 0) {
            foreach ($setting in $policyObject.psobject.Properties) {
                $currentName = if ($setting.Name -eq 'Enable') { $policy.Name } else { $setting.Name }
                if ($currentName -eq $MitigationName) {
                    if ($setting.Value.ToString() -eq 'ON') { return $true }
                }
            }
        }
    }
    return $false
}

function Find-ApplicationPath {
    param([string]$TargetAppName)
    $regPath = "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\App Paths\$TargetAppName"
    if (Test-Path $regPath) {
        $appPath = (Get-ItemProperty -Path $regPath).'(default)'
        if (Test-Path $appPath) { return $appPath }
    }
    return $null # Fallback to manual path if needed
}

#endregion

#region Main Execution
$logNames = @('Microsoft-Windows-Security-Mitigations/UserMode', 'Microsoft-Windows-Security-Mitigations/KernelMode')
$eventIDs = @(1, 2, 10, 11, 12, 36) 

try { Import-Module ProcessMitigations -ErrorAction Stop } catch { Write-Error "FATAL: Module not loaded."; return }

$appPath = Find-ApplicationPath -TargetAppName $appName
if (-not $appPath) { Write-Error "Could not automatically find path for '$appName'."; return }

Write-Host "Ensuring $friendlyAppName is registered..."
Set-ProcessMitigation -Name $appName -Enable DEP -ErrorAction SilentlyContinue | Out-Null

$allMitigationNames = Get-AllMitigationNames -TargetAppName $appName
Write-Host "Discovered $($allMitigationNames.Count) possible mitigations for $friendlyAppName."

$successfullyEnabled = @()
$disabledDueToErrors = @()
$disabledForNotApplying = @()

Write-Host "Closing any existing instances of $friendlyAppName..."
Stop-Process -Name $appName.Replace(".exe","") -Force -ErrorAction SilentlyContinue

Write-Host "Starting automated test for $friendlyAppName..."

foreach ($mitigation in $allMitigationNames) {
    Write-Host "`n" + ("-"*60)
    Write-Host "ATTEMPTING MITIGATION: $mitigation" -ForegroundColor Yellow
    
    try { Set-ProcessMitigation -Name $appName -Enable $mitigation -ErrorAction Stop } catch { Write-Warning "Could not enable '$mitigation'. Skipping."; continue }

    # --- NEW VERIFICATION STEP ---
    if (-not (Test-MitigationState -TargetAppName $appName -MitigationName $mitigation)) {
        Write-Warning "  - VERIFY: Setting for '$mitigation' did not apply successfully. Skipping stability test."
        $disabledForNotApplying += $mitigation
        # We must disable it again to ensure a clean state for the next test.
        Set-ProcessMitigation -Name $appName -Disable $mitigation -ErrorAction SilentlyContinue
        continue
    }
    Write-Host "  - VERIFY: Setting for '$mitigation' was successfully applied." -ForegroundColor Green

    $testStartTime = Get-Date

    Write-Host "  - LAUNCH: Launching $appName as STANDARD USER..."
    try {
        $shell = New-Object -ComObject Shell.Application
        $launchArgument = if ($appType -eq 'Browser') { ($testResource -join ' ') } else { "`"$testResource`"" }
        $shell.ShellExecute($appPath, $launchArgument)
    }
    catch { Write-Error "    - LAUNCH FAIL: Aborting test."; return }

    Write-Host "  - WAIT: Waiting for $delayInSeconds seconds..."
    Start-Sleep -Seconds $delayInSeconds

    Write-Host "  - CHECK: Checking for security mitigation events..."
    $events = Get-WinEvent -FilterHashtable @{LogName=$logNames; ID=$eventIDs; StartTime=$testStartTime} -ErrorAction SilentlyContinue

    if ($events) {
        Write-Warning "  - RESULT: Found event(s) for '$mitigation'. This mitigation is UNSTABLE."
        
        # Display the details of the first event found to provide context for the failure.
        $firstEvent = $events | Select-Object -First 1
        Write-Warning "    - Event Details: $($firstEvent.Message.Trim())"
        
        Write-Host "  - ACTION: Disabling '$mitigation'..."
        Set-ProcessMitigation -Name $appName -Disable $mitigation -ErrorAction SilentlyContinue
        $disabledDueToErrors += $mitigation
    }
    else {
        Write-Host "  - RESULT: No events found. Mitigation '$mitigation' appears STABLE." -ForegroundColor Green
        $successfullyEnabled += $mitigation
    }

    Stop-Process -Name $appName.Replace(".exe","") -Force -ErrorAction SilentlyContinue
    Start-Sleep -Seconds 2
}

# Final Report
Write-Host "`n" + ("="*60)
Write-Host "AUTOMATED TEST COMPLETE FOR: $friendlyAppName" -ForegroundColor Cyan
Write-Host ("="*60)
Write-Host "`nStable mitigations that remain ENABLED ($($successfullyEnabled.Count)): " -ForegroundColor Green
Write-Host ($successfullyEnabled -join ', ')
Write-Host "`nIncompatible mitigations (caused instability) that were DISABLED ($($disabledDueToErrors.Count)): " -ForegroundColor Yellow
if ($disabledDueToErrors) { Write-Host ($disabledDueToErrors -join ', ') } else { Write-Host "None" }
Write-Host "`nMitigations that failed to apply (hardware/OS incompatibility) that are DISABLED ($($disabledForNotApplying.Count)): " -ForegroundColor Magenta
if ($disabledForNotApplying) { Write-Host ($disabledForNotApplying -join ', ') } else { Write-Host "None" }
Write-Host "`n`n$friendlyAppName is now configured with the final, stable settings." -ForegroundColor Cyan

# --- Save results to a file for the verification script ---
$resultsPath = "C:\Automated_App_Testing"
if (-not (Test-Path -Path $resultsPath)) { New-Item -Path $resultsPath -ItemType Directory }
$resultsFile = Join-Path $resultsPath "stable_mitigations_for_$($appName).json"
$successfullyEnabled | ConvertTo-Json | Out-File -FilePath $resultsFile -Encoding utf8
Write-Host "`n`n$friendlyAppName is now configured with the final, stable settings." -ForegroundColor Cyan
Write-Host "A list of stable settings has been saved to '$resultsFile' for verification." -ForegroundColor Cyan
#endregion

#endregion



<#
Use these code blocks, by application
________________EDGE____________________
$friendlyAppName = "Microsoft Edge"
$appName         = "msedge.exe"
$appType         = "Browser" # 'Browser' or 'DocumentApp'
$testResource    = @("https://www.google.com", "https://www.sans.org", "https://www.microsoft.com")
$delayInSeconds  = 15
________________________________________
________________Chrome__________________
$friendlyAppName = "Google Chrome"
$appName         = "chrome.exe"
$appType         = "Browser" # 'Browser' or 'DocumentApp'
$testResource    = @("https://www.google.com", "https://www.sans.org", "https://www.microsoft.com")
$delayInSeconds  = 15
________________________________________
_____________Mozilla Firefox____________
$friendlyAppName = "Mozilla Firefox"
$appName         = "firefox.exe"
$appType         = "Browser" # 'Browser' or 'DocumentApp'
$testResource    = @("https://www.google.com", "https://www.sans.org", "https://www.mozilla.org")
$delayInSeconds  = 15
_________________________________________
___________Adobe Acrobat Reader__________
$friendlyAppName = "Adobe Acrobat Reader"
$appName         = "AcroRd32.exe" # Or "Acrobat.exe" for the full version
$appType         = "DocumentApp" # 'Browser' or 'DocumentApp'
$testResource    = "C:\Automated_App_Testing\test.pdf"
$delayInSeconds  = 20
_________________________________________
_______________Microsoft Word____________
$friendlyAppName = "Microsoft Word"
$appName         = "WINWORD.EXE"
$appType         = "DocumentApp" # 'Browser' or 'DocumentApp'
$testResource    = "C:\Automated_App_Testing\test.docx"
$delayInSeconds  = 25 # Longer delay for larger Office apps
_________________________________________
______________Microsoft Excel____________
$friendlyAppName = "Microsoft Excel"
$appName         = "EXCEL.EXE"
$appType         = "DocumentApp" # 'Browser' or 'DocumentApp'
$testResource    = "C:\Automated_App_Testing\test.xlsx"
$delayInSeconds  = 25
__________________________________________
______________Microsoft PowerPoint________
$friendlyAppName = "Microsoft PowerPoint"
$appName         = "POWERPNT.EXE"
$appType         = "DocumentApp" # 'Browser' or 'DocumentApp'
$testResource    = "C:\Automated_App_Testing\test.pptx"
$delayInSeconds  = 25
__________________________________________
______________Microsoft Teams_____________
$friendlyAppName = "Microsoft Teams"
$appName         = "ms-teams.exe"
$appType         = "Browser" # We use 'Browser' to handle an empty URL list gracefully
$testResource    = @() # No specific resource to open, just launch
$delayInSeconds  = 30 # Teams can be slow to start
___________________________________________


#>


